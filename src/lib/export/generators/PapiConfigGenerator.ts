import type { ChainConfig } from '../types';

export class PapiConfigGenerator {
    private readonly chainConfig: ChainConfig;

    constructor(chainConfig: ChainConfig) {
        this.chainConfig = chainConfig;
    }

    public generateConfig(): string {
        return `#!/usr/bin/env node

/**
 * PAPI Configuration for ${this.chainConfig.chainId}
 * Generated by Polkadot API Playground
 * 
 * Run this script to set up the chain descriptors:
 * node papi-setup.js
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const CHAIN_CONFIG = {
  chainId: '${this.chainConfig.chainId}',
  descriptorKey: '${this.chainConfig.descriptorKey}',
  papiName: '${this.chainConfig.papiName}',
  primaryEndpoint: '${this.chainConfig.endpoint}',
  alternativeEndpoints: ${JSON.stringify(this.chainConfig.alternativeEndpoints, null, 2)}
};

console.log(\`Setting up PAPI for \${CHAIN_CONFIG.chainId}...\`);

// Ensure .papi directory exists
const papiDir = path.join(process.cwd(), '.papi');
if (!fs.existsSync(papiDir)) {
  console.log('Creating .papi directory...');
  fs.mkdirSync(papiDir, { recursive: true });
}

// Function to attempt adding chain with different approaches
async function setupChain() {
  let success = false;
  let lastError = null;

  // Approach 1: Use well-known chain name
  try {
    console.log('Attempting with well-known chain name...');
    execSync(\`npx papi add \${CHAIN_CONFIG.descriptorKey} -n \${CHAIN_CONFIG.papiName}\`, {
      stdio: 'inherit',
      timeout: 5 * 60 * 1000 // 5 minutes
    });
    success = true;
    console.log('✅ Successfully set up chain using well-known name');
  } catch (error) {
    lastError = error;
    console.log('❌ Well-known name approach failed');
  }

  // Approach 2: Use primary endpoint
  if (!success) {
    try {
      console.log(\`Attempting with primary endpoint: \${CHAIN_CONFIG.primaryEndpoint}\`);
      execSync(\`npx papi add \${CHAIN_CONFIG.descriptorKey} -n \${CHAIN_CONFIG.papiName} -w \${CHAIN_CONFIG.primaryEndpoint}\`, {
        stdio: 'inherit',
        timeout: 5 * 60 * 1000
      });
      success = true;
      console.log('✅ Successfully set up chain using primary endpoint');
    } catch (error) {
      lastError = error;
      console.log('❌ Primary endpoint approach failed');
    }
  }

  // Approach 3: Try alternative endpoints
  if (!success) {
    for (const endpoint of CHAIN_CONFIG.alternativeEndpoints) {
      try {
        console.log(\`Attempting with alternative endpoint: \${endpoint}\`);
        execSync(\`npx papi add \${CHAIN_CONFIG.descriptorKey} -n \${CHAIN_CONFIG.papiName} -w \${endpoint}\`, {
          stdio: 'inherit',
          timeout: 5 * 60 * 1000
        });
        success = true;
        console.log(\`✅ Successfully set up chain using endpoint: \${endpoint}\`);
        break;
      } catch (error) {
        lastError = error;
        console.log(\`❌ Alternative endpoint \${endpoint} failed\`);
      }
    }
  }

  if (!success) {
    console.error('❌ All approaches failed. Last error:');
    console.error(lastError?.message || 'Unknown error');
    console.error('\\nTroubleshooting:');
    console.error('1. Check your internet connection');
    console.error('2. Verify the chain endpoints are accessible');
    console.error('3. Try running: npx papi --help');
    console.error('4. Check the PAPI documentation: https://papi.how');
    process.exit(1);
  }

  console.log('\\n🎉 PAPI setup completed successfully!');
  console.log('You can now use the component in your application.');
}

// Run setup
setupChain().catch(error => {
  console.error('Setup failed:', error);
  process.exit(1);
});
`;
    }

    public generatePackageConfig(): string {
        return JSON.stringify({
            version: "0.0.1",
            entries: {
                [this.chainConfig.descriptorKey]: {
                    chain: this.chainConfig.papiName,
                    metadata: `.papi/metadata/${this.chainConfig.papiName}.scale`,
                    descriptors: `.papi/descriptors/src/${this.chainConfig.descriptorKey}.ts`
                }
            }
        }, null, 2);
    }
}